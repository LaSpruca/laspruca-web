import{S as t,i as e,s as o,B as a,j as n,m as i,o as r,p as s,q as h,x as c,u as l,v as u,Q as p,e as d,t as f,k as m,c as g,a as y,g as w,d as b,n as $,f as v,E as k}from"../../chunks/vendor-2d7e6306.js";import{P as x}from"../../chunks/ProjectLayout-17db31d6.js";function I(t){let e,o,a,n,i,r,s,h,c,l,u;return{c(){e=d("p"),o=f("This was a small project that I decided to do for the hell of it. I have made many BF interperters, but never a BF compiler, so I thought why not.\nOriginally I targeted C intermediate language, but after many bugs, I switch to C++ then finally Rust. The application currently relies on "),a=d("code"),n=f("rustc"),i=f("\nto be installed to compile the intermediate."),r=m(),s=d("h2"),h=f("How it works"),c=m(),l=d("p"),u=f("The application works by taking series of files as input. It then goes through each file and compiles it down to rust. First it reduces the input source code\ninto an array of tokens and the number of times the appear immediately following each other. The next step is to convert this syntax thing into rust source code.\nThe way that the operators is pretty self explanatory, although the inc. pointer and dec. point are a bit funky, using some math to figure out what to set pointer\nthe pointer to after an overflow. After this, the resulting source code from each of the files in combined into one long string and dumped into an intermediate rust\nsource file, where it is then compiled to a native binary.")},l(t){e=g(t,"P",{});var p=y(e);o=w(p,"This was a small project that I decided to do for the hell of it. I have made many BF interperters, but never a BF compiler, so I thought why not.\nOriginally I targeted C intermediate language, but after many bugs, I switch to C++ then finally Rust. The application currently relies on "),a=g(p,"CODE",{});var d=y(a);n=w(d,"rustc"),d.forEach(b),i=w(p,"\nto be installed to compile the intermediate."),p.forEach(b),r=$(t),s=g(t,"H2",{});var f=y(s);h=w(f,"How it works"),f.forEach(b),c=$(t),l=g(t,"P",{});var m=y(l);u=w(m,"The application works by taking series of files as input. It then goes through each file and compiles it down to rust. First it reduces the input source code\ninto an array of tokens and the number of times the appear immediately following each other. The next step is to convert this syntax thing into rust source code.\nThe way that the operators is pretty self explanatory, although the inc. pointer and dec. point are a bit funky, using some math to figure out what to set pointer\nthe pointer to after an overflow. After this, the resulting source code from each of the files in combined into one long string and dumped into an intermediate rust\nsource file, where it is then compiled to a native binary."),m.forEach(b)},m(t,p){v(t,e,p),k(e,o),k(e,a),k(a,n),k(e,i),v(t,r,p),v(t,s,p),k(s,h),v(t,c,p),v(t,l,p),k(l,u)},d(t){t&&b(e),t&&b(r),t&&b(s),t&&b(c),t&&b(l)}}}function T(t){let e,o;const p=[t[0],B];let d={$$slots:{default:[I]},$$scope:{ctx:t}};for(let n=0;n<p.length;n+=1)d=a(d,p[n]);return e=new x({props:d}),{c(){n(e.$$.fragment)},l(t){i(e.$$.fragment,t)},m(t,a){r(e,t,a),o=!0},p(t,[o]){const a=1&o?s(p,[1&o&&h(t[0]),0&o&&h(B)]):{};2&o&&(a.$$scope={dirty:o,ctx:t}),e.$set(a)},i(t){o||(c(e.$$.fragment,t),o=!0)},o(t){l(e.$$.fragment,t),o=!1},d(t){u(e,t)}}}const B={title:"BFC",description:"A Brainf**k compiler written in rust",website:"https://crates.io/crates/bf-compile",gitRepo:"https://github.com/laspruca/bfc",date:"2021-05-21"};function F(t,e,o){return t.$$set=t=>{o(0,e=a(a({},e),p(t)))},[e=p(e)]}export default class extends t{constructor(t){super(),e(this,t,F,T,o,{})}}export{B as metadata};
